<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<generator uri="http://jekyllrb.com" version="3.7.2">Jekyll</generator>
<link href="http://crail.incubator.apache.org//feed.xml" rel="self" type="application/atom+xml" />
<link href="http://crail.incubator.apache.org//" rel="alternate" type="text/html" />
<updated>2018-02-21T16:04:49+01:00</updated>
<id>http://crail.incubator.apache.org//</id>
<title>The Apache Crail (Incubating) Project</title>
<entry>
<title>Apache</title>
<link href="http://crail.incubator.apache.org//blog/2018/01/apache.html" rel="alternate" type="text/html" title="Apache" />
<published>2018-01-22T00:00:00+01:00</published>
<updated>2018-01-22T00:00:00+01:00</updated>
<id>http://crail.incubator.apache.org//blog/2018/01/apache</id>
<content type="html" xml:base="http://crail.incubator.apache.org//blog/2018/01/apache.html">&lt;p&gt;Crail is now an Apache Incubator project!&lt;/p&gt;
</content>
<category term="news" />
<summary>Crail is now an Apache Incubator project!</summary>
</entry>
<entry>
<title>Iops</title>
<link href="http://crail.incubator.apache.org//blog/2017/11/iops.html" rel="alternate" type="text/html" title="Iops" />
<published>2017-11-23T00:00:00+01:00</published>
<updated>2017-11-23T00:00:00+01:00</updated>
<id>http://crail.incubator.apache.org//blog/2017/11/iops</id>
<content type="html" xml:base="http://crail.incubator.apache.org//blog/2017/11/iops.html">&lt;p&gt;New blog &lt;a href=&quot;{{ site.base }}/blog/2017/11/crail-metadata.html&quot;&gt;post&lt;/a&gt; about Crail’s metadata performance and scalability&lt;/p&gt;
</content>
<category term="news" />
<summary>New blog post about Crail’s metadata performance and scalability</summary>
</entry>
<entry>
<title>Crail Storage Performance – Part III: Metadata</title>
<link href="http://crail.incubator.apache.org//blog/2017/11/crail-metadata.html" rel="alternate" type="text/html" title="Crail Storage Performance -- Part III: Metadata" />
<published>2017-11-21T00:00:00+01:00</published>
<updated>2017-11-21T00:00:00+01:00</updated>
<id>http://crail.incubator.apache.org//blog/2017/11/crail-metadata</id>
<content type="html" xml:base="http://crail.incubator.apache.org//blog/2017/11/crail-metadata.html">&lt;div style=&quot;text-align: justify&quot;&gt;
&lt;p&gt;
This is part III of our series of posts discussing Crail's raw storage performance. This part is about Crail's metadata performance and scalability.
&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;hardware-configuration&quot;&gt;Hardware Configuration&lt;/h3&gt;

&lt;p&gt;The specific cluster configuration used for the experiments in this blog:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cluster
    &lt;ul&gt;
      &lt;li&gt;8 node x86_64 cluster&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Node configuration
    &lt;ul&gt;
      &lt;li&gt;CPU: 2 x Intel(R) Xeon(R) CPU E5-2690 0 @ 2.90GHz&lt;/li&gt;
      &lt;li&gt;DRAM: 96GB DDR3&lt;/li&gt;
      &lt;li&gt;Network: 1x100Gbit/s Mellanox ConnectX-5&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Software
    &lt;ul&gt;
      &lt;li&gt;Ubuntu 16.04.3 LTS (Xenial Xerus) with Linux kernel version 4.10.0-33-generic&lt;/li&gt;
      &lt;li&gt;Crail 1.0, internal version 2993&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;crail-metadata-operation-overview&quot;&gt;Crail Metadata Operation Overview&lt;/h3&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
As described in &lt;a href=&quot;{{ site.base }}/blog/2017/08/crail-memory.html&quot;&gt;part I&lt;/a&gt;, Crail data operations are composed of actual data transfers and metadata operations. Examples of metadata operations are operations for creating or modifying the state of a file, or operations to lookup the storage server that stores a particular range (block) of a file. In Crail, all the metadata is managed by the namenode(s) (as opposed to the data which is managed by the storage nodes). Clients interact with Crail namenodes via Remote Procedure Calls (RPCs). Crail supports multiple RPC protocols for different types of networks and also offers a pluggable RPC interface so that new RPC bindings can be implemented easily. On RDMA networks, the default DaRPC (&lt;a href=&quot;https://dl.acm.org/citation.cfm?id=2670994&quot;&gt;DaRPC paper&lt;/a&gt;, &lt;a href=&quot;http://github.com/zrlio/darpc&quot;&gt;DaRPC GitHub&lt;/a&gt;) based RPC binding provides the best performance. The figure below gives an overview of the Crail metadata processing in a DaRPC configuration. 
&lt;/p&gt;
&lt;/div&gt;

&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;{{ site.base }}/img/blog/crail-metadata/rpc.png&quot; width=&quot;480&quot; /&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
Crail supports partitioning of metadata across several namenods. Thereby, metadata operations issued by clients are hashed to a particular namenode depending on the name of object the operation attempts to create or retrieve. With the DaRPC binding, RPC messages are exchanged using RDMA send/recv operations. At the server, RPC processing is parallelized across different cores. To minimize locking and cache contention, each core handles a disjoint set of client connections. Connections assigned to the same core share the same RDMA completion queue which is processed exclusively by that given core. All the network queues, including send-, recv- and completion queues are mapped into user-space and accessed directly from within the JVM process. Since Crail offers a hierarchical storage namespace, metadata operations to create, delete or rename new storage resources effectively result in modifications to a tree-like data structure at the namenode. These structural operations require a somewhat more expensive locking than the more lightweight operations used to lookup the file status or to extend a file with a new storage block. Consequently, Crail namenodes use two separate data structures to manage metadata: (a) a basic tree data structure that requires directory-based locking, and (b) a fast lock-free map to lookup of storage resources that are currently being read or written.
&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;experimental-setup&quot;&gt;Experimental Setup&lt;/h3&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
In two of the previous blogs (&lt;a href=&quot;{{ site.base }}/blog/2017/08/crail-memory.html&quot;&gt;DRAM&lt;/a&gt;, &lt;a href=&quot;{{ site.base }}/blog/2017/08/crail-nvme-fabrics-v1.html&quot;&gt;NVMf&lt;/a&gt;) we have already shown that Crail metadata operations are very low latency. Essentially a single metadata operation issued by a remote client takes 5-6 microseconds, which is only slightly more than the raw network latency of the RDMA network fabric. In this blog, we want to explore the scalability of Crail's metadata management, that is, the number of clients Crail can support, or how Crail scales as the cluster size increases. The level of scalability of Crail is mainly determined by the number of metadata operations Crail can process concurrently, a metric that is often referred to as IOPS. The higher the number of IOPS the system can handle, the more clients can concurrently use Crail without performance loss. 
&lt;/p&gt;
&lt;p&gt;
An important metadata operation is ''getFile()'', which is used by clients to lookup the status of a file (whether the file exists, what size it has, etc.). The ''getFile()'' operation is served by Crail's fast lock-free map and in spirit is very similar to the ''getBlock()'' metadata operation (used by clients to query which storage nodes holds a particular block). In a typical Crail use case, ''getFile()'' and ''getBlock()'' are responsible for the peak metadata load at a namenode. In this experiment, we measure the achievable IOPS on the server side in an artificial configuration with many clients distributed across the cluster issuing ''getFile()'' in a tight loop. Note that the client side RPC interface in Crail is asynchronous, thus, clients can issue multiple metadata operations without blocking while asynchronously waiting for the result. In the experiments below, each client may have a maximum of 128 ''getFile()'' operations outstanding at any point in time. In a practical scenario, Crail clients may also have multiple metadata operations in flight either because clients are shared by different cores, or because Crail interleaves metadata and data operations (see &lt;a href=&quot;{{ site.base }}/blog/2017/08/crail-memory.html&quot;&gt;DRAM&lt;/a&gt;). What makes the benchmark artificial is that clients exclusively focus on generating load for the namenode and thereby are neither performing data operations nor are they doing any compute. The basic command of the benchmark as executed by each of the individual clients is given by the following command:
&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./bin/crail iobench -t getMultiFileAsync -f / -k 10000000 -b 128
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
Where ''-t'' specifies the benchmark to run, ''-f'' specifies the path on the
Crail file system to be used for the benchmark, ''-k'' specifies the number of
iterations to be performed by the benchmark
(how many times will the benchmark execute ''getFile()'') and
''-b'' specifies the maximum number of requests in flight.
&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;single-namenode-scalability&quot;&gt;Single Namenode Scalability&lt;/h3&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
In the first experiment, we measure the aggregated number of metadata operations a single Crail namenode can handle per second. The namenode runs on 8 physical cores with hyper-threading disabled. The result is shown in the first graph below, labeled ''Namenode IOPS''. The namenode only gets saturated with more than 16 clients. The graph shows that the namenode can handle close to 10 million ''getFile()'' operations per second. With significantly more clients, the overall number of IOPS drops slightly, as more resources are being allocated on the single RDMA card, which basically creates a contention on hardware resources.
&lt;/p&gt;
&lt;p&gt; 
As comparison, we measure the raw number of IOPS, which can be executed on the RDMA network. We measure the raw number using ib_send_bw. We configured ib_send_bw with the same parameters in terms of RDMA configuration as the namenode. This means, we instructed ib_send_bw not to do CQ moderation, and to use a receive queue and a send queue of length 32, which equals the length of the namenode queues. Note that the default configuration of ib_send_bw uses CQ moderation and does preposting of send operations, which can only be done, if the operation is known in advance. This is not the case in a real system, like crail's namenode. The basic ib_send_bw command is given below:
&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ib_send_bw -s 1 -Q 1 -r 32 -t 32 -n 10000000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
Where ''-s 1'' specifies to send packets with a payload of 1 (we don't want to
measure the transmission time of data, just the number of I/O operations),
''-Q 1'' specifies not to do CQ moderation, ''-r 32'' specifies the receive
queue length to be 32, ''-t 32'' specifies the send queue length to be 32
and ''-n'' specifies the number of
iterations to be performed by ib_send_bw.
&lt;/p&gt;
&lt;/div&gt;
&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
The line of the raw number of IOPS, labeled ''ib send'' is shown in the same graph. With this measurement we show that Crail's namenode IOPS are similar to the raw ib_send_bw IOPS with the same configuration.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;{{ site.base }}/img/blog/crail-metadata/namenode_ibsend_iops64.svg&quot; width=&quot;550&quot; /&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
If one starts ib_send_bw without specifying the queue sizes or whether or not to use CQ moderation, the raw number of IOPS might be higher. This is due to the fact, that the default values of ib_send_bw use a receive queue of 512, a send queue of 128 and CQ moderation of 100, meaning that a new completion is generated only after 100 sends. As comparison, we did this
measurement too and show the result, labeled 'ib_send CQ mod', in the same graph. Fine tuning of receive and send queue sizes, CQ moderation size, postlists etc might lead to a higher number of IOPS. 
&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;multiple-namenode-scalability&quot;&gt;Multiple Namenode Scalability&lt;/h3&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
To increase the number of IOPS the overall system can handle, we allow starting multiple namenode instances. Hot metadata operations, such as ''getFile()'', are distributed over all running instances of the namenode. ''getFile()'' is implemented such that no synchronization among the namenodes is required. As such, we expect good scalability. The graph below compares the overall IOPS of a system with one namenode to a system with two namenodes and four namenodes.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;{{ site.base }}/img/blog/crail-metadata/namenode_multi64.svg&quot; width=&quot;550&quot; /&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
We show in this graph that the system can handle around 17Mio IOPS with two namenodes and 28Mio IOPS with four namenodes (with more than 64 clients we measured the number of IOPS to be slightly higher than 30Mio IOPS). Having multiple namenode instances matters especially with a higher number of clients. In the graph we see that the more clients we have the more we can benefit from a second namenode instance or even more instances.
&lt;/p&gt;
&lt;/div&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
We only have 7 physical nodes available to run the client processes. This
means, after 7 client processes, processes start sharing a physical machine.
With 64 client processes, each machine runs 9 (10 in one case) client
instances, which share the cores and the resources of the RDMA hardware.
We believe this is the reason, why the graphs appear not to scale linearly.
The number of total IOPS is client-bound, not namenode-bound.
With more physical machines, we believe that scalability could be shown
much better. Again, there is absolutely no communication among the
namenodes happening, which should lead to linear scalability.
&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;cluster-sizes&quot;&gt;Cluster sizes&lt;/h3&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
Let us look at a concrete application, which ideally runs on a large cluster:
TeraSort. In a previous blog, &lt;a href=&quot;{{ site.base }}/blog/2017/01/sorting.html&quot;&gt;sorting&lt;/a&gt;,
we analyze performance characteristics of TeraSort on Crail on a big cluster
of 128 nodes, where we run 384 executors in total. This already proves that
Crail can at least handle 384 clients. Now we analyze the theoretical number
of clients without performance loss at the namenode. Still this theoretical
number is not a hard limit on the number of clients. Just adding more
clients would start dropping the number of IOPS per client (not at the
namenode).
&lt;/p&gt;
&lt;/div&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
In contrast to the benchmarks above, a real-world application, like TeraSort,
does not issue RPC requests in a tight loop. It rather does sorting
(computation), file reading and writing and and of course a certain amount of
RPCs to manage the files.
&lt;/p&gt;
&lt;/div&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
We would like to know how many RPCs a run of TeraSort generates and therefore
how big the load in terms of number of IOPS is at the namenode for a
real-world application.
We run TeraSort on a data set of 200GB and measured the
number of IOPS at the namenode with 4 executors, 8 executors and 12 executors.
Every executor runs 12 cores. For this experiment, we use a single namenode
instance. We plot the distribution of the number of IOPS measured at the
namenode over the elapsed runtime of the TeraSort application.
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;{{ site.base }}/img/blog/crail-metadata/terasort_iops.svg&quot; width=&quot;550&quot; /&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
From the graph we pick the peak number of IOPS measured
throughout the execution time for all three cases. The following table
shows the three peak IOPS numbers:
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;#Executor nodes&lt;/th&gt;
      &lt;th&gt;Measured IOPS&lt;/th&gt;
      &lt;th&gt;% of single namenode&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td align=&quot;right&quot;&gt;4&lt;/td&gt;
      &lt;td align=&quot;right&quot;&gt;32k&lt;/td&gt;
      &lt;td align=&quot;right&quot;&gt;0.32%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td align=&quot;right&quot;&gt;8&lt;/td&gt;
      &lt;td align=&quot;right&quot;&gt;67k&lt;/td&gt;
      &lt;td align=&quot;right&quot;&gt;0.67%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td align=&quot;right&quot;&gt;12&lt;/td&gt;
      &lt;td align=&quot;right&quot;&gt;107k&lt;/td&gt;
      &lt;td align=&quot;right&quot;&gt;1.07%&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
From this table we see that it scales linearly. Even more important,
we notice that with 12 nodes we still use only around 1% of the
number of IOPS a single namenode can handle.
If we extrapolate this to a
100%, we can handle a cluster size of almost 1200 nodes (1121 clients being just
below 10Mio IOPS at the namenode). The
extrapolated numbers would look like this:
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;#Namenodes&lt;/th&gt;
      &lt;th&gt;Max IOPS by  namenodes&lt;/th&gt;
      &lt;th&gt;#Executor nodes&lt;/th&gt;
      &lt;th&gt;Extrapolated IOPS&lt;/th&gt;
      &lt;th&gt;% of all namenodes&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td align=&quot;right&quot;&gt;1&lt;/td&gt;
      &lt;td align=&quot;right&quot;&gt;10000k&lt;/td&gt;
      &lt;td align=&quot;right&quot;&gt;1121&lt;/td&gt;
      &lt;td align=&quot;right&quot;&gt;9996k&lt;/td&gt;
      &lt;td align=&quot;right&quot;&gt;99.96%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td align=&quot;right&quot;&gt;1&lt;/td&gt;
      &lt;td align=&quot;right&quot;&gt;10000k&lt;/td&gt;
      &lt;td align=&quot;right&quot;&gt;1200&lt;/td&gt;
      &lt;td align=&quot;right&quot;&gt;10730k&lt;/td&gt;
      &lt;td align=&quot;right&quot;&gt;107.3%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td align=&quot;right&quot;&gt;2&lt;/td&gt;
      &lt;td align=&quot;right&quot;&gt;17000k&lt;/td&gt;
      &lt;td align=&quot;right&quot;&gt;1906&lt;/td&gt;
      &lt;td align=&quot;right&quot;&gt;16995k&lt;/td&gt;
      &lt;td align=&quot;right&quot;&gt;99.97%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td align=&quot;right&quot;&gt;4&lt;/td&gt;
      &lt;td align=&quot;right&quot;&gt;30000k&lt;/td&gt;
      &lt;td align=&quot;right&quot;&gt;3364&lt;/td&gt;
      &lt;td align=&quot;right&quot;&gt;29995k&lt;/td&gt;
      &lt;td align=&quot;right&quot;&gt;99.98%&lt;/td&gt;
    &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
Of course we know that there is no system with perfect linear scalability.
But even if we would loose 50% of the number of IOPS (compared to the
theoretical maximum) on a big cluster, Crail could still handle a cluster size
of 600 nodes and a single namenode without any performance loss at the
namenode.
Should we still want to run an application like TeraSort on a bigger cluster,
we can add a second namenode or have even more instances of namenodes
to ensure that clients do not suffer from contention in terms of IOPS at
the namenode.
&lt;/p&gt;
&lt;/div&gt;

&lt;div style=&quot;text-align: justify&quot;&gt;
&lt;p&gt;
We believe that the combination of benchmarks above, the scalability
experiments and the real-world
application of TeraSort shows clearly that Crail and Crail's namenode can handle
a big cluster of at least several hundreds of nodes, theoretically up to
1200 nodes with a single namenode and even more with multiple namenodes.
&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;system-comparison&quot;&gt;System comparison&lt;/h3&gt;
&lt;div style=&quot;text-align: justify&quot;&gt;
&lt;p&gt;
In this section we compare the number of IOPS Crail can handle to
two other systems:
&lt;a href=&quot;http://hadoop.apache.org/&quot;&gt;Hadoop's HDFS namenode&lt;/a&gt; and
&lt;a href=&quot;https://ramcloud.atlassian.net/wiki/spaces/RAM/overview&quot;&gt;RAMCloud&lt;/a&gt;.
&lt;/p&gt;
&lt;/div&gt;

&lt;div style=&quot;text-align: justify&quot;&gt;
&lt;p&gt;
HDFS is a well known distributed file system. Like Crail, HDFS runs
a namenode and several datanodes. The namenode implements similar functionality
as Crail's namenode, while HDFS's datanodes provide additional functionality,
like replication, for example. We are interested in the
number of IOPS the namenode can handle. As such, the datanode's functionality
is not relevant for this experiment. HDFS is implemented in Java like Crail.
Due to this high similarity in terms of functionality and language used to
implement the system, HDFS is a good candidate to compare Crail to.
&lt;/p&gt;
&lt;/div&gt;

&lt;div style=&quot;text-align: justify&quot;&gt;
&lt;p&gt;
HDFS does not use RDMA to send RPCs. Instead, RPCs are sent over a regular
IP network. In our case, it is the same 100Gbit/s ethernet-based RoCE network.
&lt;/p&gt;
&lt;/div&gt;

&lt;div style=&quot;text-align: justify&quot;&gt;
&lt;p&gt;
To measure the number of IOPS HDFS's namenode can handle, we run the same
experiment as for Crail. The clients issue a ''getFile()'' RPC to the
namenode and we vary the number of clients from 1 to 64. The following
plot shows the number of IOPS relative to the number of clients.
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;{{ site.base }}/img/blog/crail-metadata/namenode_hdfs_iops.svg&quot; width=&quot;550&quot; /&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div style=&quot;text-align: justify&quot;&gt;
&lt;p&gt;
The graph shows that the namenode can handle around 200000 IOPS. One reason
for the difference to the number of IOPS of Crail is surely that HDFS does not
use the capabilities offered by the RDMA network, while Crail does. However
this cannot be the only reason, why the namenode cannot handle more than
200000 IOPS. We would need to analyze more deeply where the bottleneck is
to find an answer. We believe that the amount of code which
gets executed at probably various layers of the software stack
is too big to achieve high performance in terms of IOPS.
&lt;/p&gt;
&lt;/div&gt;

&lt;div style=&quot;text-align: justify&quot;&gt;
&lt;p&gt;
RAMCloud is a fast key-value store, which makes use of the RDMA network
to reach low latency and high throughput. It runs one master coordinator and
and optionally several slave coordinators, which can take over, if the master
coordinator fails. Coordinator persistence can be achieved
by external persistent storage, like Zookeeper or LogCabin.
RAMCloud runs several storage servers, which
store key-value pairs in RAM. Optionally, replicas can be stored on secondary
storage, which provides persistence. RAMCloud is implemented in C++. Therefore
it is natively compiled code.
&lt;/p&gt;
&lt;/div&gt;

&lt;div style=&quot;text-align: justify&quot;&gt;
&lt;p&gt;
We are interested in the number of IOPS RAMCloud can handle. We decided
to run the readThroughput benchmark of RAMCloud's ClusterPerf program, which
measures the number of object reads per second. This is probably the closest
benchmark to the RPC benchmark of Crail and HDFS.
&lt;/p&gt;
&lt;/div&gt;

&lt;div style=&quot;text-align: justify&quot;&gt;
&lt;p&gt;
For a fair comparison, we run RAMCloud without any persistence, so without
Zookeeper and without replicas to secondary storage. We run one coordinator
and one storage server, which is somewhat similar to running one namenode
in the Crail and HDFS cases. Also, we wanted to vary the number of clients
from 1 to 64. At the moment we can only get results for up to 16 clients.
We asked the RAMCloud developers for possible reasons and got to know that the
reason is a starvation bug in the benchmark (not in the RAMCloud system
itself). The RAMCloud developers are looking into this issue. We will update
the blog with the latest numbers as soon as the bug is fixed.
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;{{ site.base }}/img/blog/crail-metadata/ramcloud_iops.svg&quot; width=&quot;550&quot; /&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div style=&quot;text-align: justify&quot;&gt;
&lt;p&gt;
RAMCloud reaches a peak of 1.12Mio IOPS with 14 clients. The utilization of the
dispatcher thread is at 100% already with 10 clients. Even with more clients,
the number of IOPS won't get higher than 1.12Mio, because the
dispatcher thread is the bottleneck, as can be seen in the graph.
In addition, we got a confirmation from the developers that more than
10 clients will not increase the number of IOPS.
So we think that the measurements are not unfair, even if we do not have
results for more than 16 clients. Again, we we will update the blog
with a higher number of clients, as soon as the bug is fixed.
&lt;/p&gt;
&lt;/div&gt;

&lt;div style=&quot;text-align: justify&quot;&gt;
&lt;p&gt;
Let us now summarize the number of IOPS of all three systems in one plot
below. For a fair comparison, Crail runs only one namenode for this
experiments and we compare the results to RAMCloud with one coordinator and
one storage server (without replication as described above) and the one
namenode instance of HDFS. We see that Crail's single namenode can handle
a much bigger number of RPCs compared to the other two systems (remember
that Crail can run multiple namenodes and we measured a number of IOPS
of 30Mio/s with 4 namenodes).
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;{{ site.base }}/img/blog/crail-metadata/max_iops_crail_hdfs_ramcloud.svg&quot; width=&quot;550&quot; /&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div style=&quot;text-align: justify&quot;&gt;
&lt;p&gt;
HDFS is deployed on production clusters and handles real workloads
with roughly 200000 IOPS. We believe that Crail, which can handle a much
bigger number of IOPS, is able to run real workloads on very large
clusters. A common assumption is that Java-based implementations suffer from
performance loss. We show that a Java-based system can handle a high amount
of operations even compared to a C++-based system like RAMCloud.
&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
In this blog we show three key points of Crail: First, Crail's namenode performs the same as ib_send_bw with realistic parameters in terms of IOPS. This shows that the actual processing of the RPC is implemented efficiently. Second, with only one namenode, Crail performs 10x to 50x better than RAMCloud and HDFS, two popular systems, where RAMCloud is RDMA-based and implemented natively. Third, Crail's metadata service can be scaled out to serve large number of clients. We have shown that Crail offers near linear scaling with up to 4 namenodes, offering a performance that is sufficient to serve several 1000s of clients. 
&lt;/p&gt;
&lt;/div&gt;

</content>
<author>
<name>Adrian Schuepbach and Patrick Stuedi</name>
</author>
<category term="blog" />
<summary>This is part III of our series of posts discussing Crail's raw storage performance. This part is about Crail's metadata performance and scalability.</summary>
</entry>
<entry>
<title>Floss</title>
<link href="http://crail.incubator.apache.org//blog/2017/11/floss.html" rel="alternate" type="text/html" title="Floss" />
<published>2017-11-17T00:00:00+01:00</published>
<updated>2017-11-17T00:00:00+01:00</updated>
<id>http://crail.incubator.apache.org//blog/2017/11/floss</id>
<content type="html" xml:base="http://crail.incubator.apache.org//blog/2017/11/floss.html">&lt;p&gt;Crail features in the &lt;a href=&quot;https://twit.tv/shows/floss-weekly/episodes/458?autostart=false&quot;&gt;FLOSS weekly podcast&lt;/a&gt;&lt;/p&gt;
</content>
<category term="news" />
<summary>Crail features in the FLOSS weekly podcast</summary>
</entry>
<entry>
<title>Blog</title>
<link href="http://crail.incubator.apache.org//blog/2017/11/blog.html" rel="alternate" type="text/html" title="Blog" />
<published>2017-11-17T00:00:00+01:00</published>
<updated>2017-11-17T00:00:00+01:00</updated>
<id>http://crail.incubator.apache.org//blog/2017/11/blog</id>
<content type="html" xml:base="http://crail.incubator.apache.org//blog/2017/11/blog.html">&lt;p&gt;New blog &lt;a href=&quot;{{ site.base }}/blog/2017/11/rdmashuffle.html&quot;&gt;post&lt;/a&gt; about SparkRDMA and Crail shuffle plugins&lt;/p&gt;
</content>
<category term="news" />
<summary>New blog post about SparkRDMA and Crail shuffle plugins</summary>
</entry>
<entry>
<title>Spark Shuffle: SparkRDMA vs Crail</title>
<link href="http://crail.incubator.apache.org//blog/2017/11/rdmashuffle.html" rel="alternate" type="text/html" title="Spark Shuffle: SparkRDMA vs Crail" />
<published>2017-11-17T00:00:00+01:00</published>
<updated>2017-11-17T00:00:00+01:00</updated>
<id>http://crail.incubator.apache.org//blog/2017/11/rdmashuffle</id>
<content type="html" xml:base="http://crail.incubator.apache.org//blog/2017/11/rdmashuffle.html">&lt;div style=&quot;text-align: justify&quot;&gt;
&lt;p&gt;
This blog is comparing the shuffle performance of Crail with SparkRDMA, an alternative RDMA-based shuffle plugin for Spark.
&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;hardware-configuration&quot;&gt;Hardware Configuration&lt;/h3&gt;

&lt;p&gt;The specific cluster configuration used for the experiments in this blog:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cluster
    &lt;ul&gt;
      &lt;li&gt;8 compute + 1 management node x86_64 cluster&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Node configuration
    &lt;ul&gt;
      &lt;li&gt;CPU: 2 x Intel(R) Xeon(R) CPU E5-2690 0 @ 2.90GHz&lt;/li&gt;
      &lt;li&gt;DRAM: 96GB DDR3&lt;/li&gt;
      &lt;li&gt;Network: 1x100Gbit/s Mellanox ConnectX-5&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Software
    &lt;ul&gt;
      &lt;li&gt;Ubuntu 16.04.3 LTS (Xenial Xerus) with Linux kernel version 4.10.0-33-generic&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/zrlio/crail&quot;&gt;Crail 1.0&lt;/a&gt;, commit a45c8382050f471e9342e1c6cf25f9f2001af6b5&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;&quot;&gt;Crail Shuffle plugin&lt;/a&gt;, commit 2273b5dd53405cab3389f5c1fc2ee4cd30f02ae6&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/Mellanox/SparkRDMA&quot;&gt;SparkRDMA&lt;/a&gt;, commit d95ce3e370a8e3b5146f4e0ab5e67a19c6f405a5 (latest master on 8th of November 2017)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;overview&quot;&gt;Overview&lt;/h3&gt;
&lt;div style=&quot;text-align: justify&quot;&gt;
&lt;p&gt;
Lately there has been an increasing interest in the community to include RDMA networking into data processing frameworks like Spark and Hadoop. One natural spot to integrate RDMA is in the shuffle operation that involves all-to-all network communication pattern. Naturally, due to its performance requirements the shuffle operation is of interest to us as well, and we have developed a Spark plugin for shuffle. In our previous blog posts, we have already shown that the Crail Shuffler achieves great workload-level speedups compared to vanilla Spark. In this blog post, we take a look at another recently proposed design called &lt;a href=&quot;https://github.com/Mellanox/SparkRDMA&quot;&gt;SparkRDMA&lt;/a&gt; (&lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-22229&quot;&gt;SPARK-22229 JIRA&lt;/a&gt;). SparkRDMA proposes to improve the shuffle performance of Spark by performing data transfers over RDMA. For this, the code manages its own off-heap memory which needs to be registered with the NIC for RDMA use. It supports two ways to store shuffle data between the stages: (1) shuffle data is stored in regular files (just like vanilla Spark) but the data transfer is implemented via RDMA, (2) data is stored in memory (allocated and registered for RDMA transfer) and the data transfer is implemented via RDMA. We call it the &quot;last-mile&quot; approach where just the networking operations are replaced by the RDMA operations.
&lt;/p&gt;
&lt;p&gt;
In contrast, the Crail shuffler plugin takes a more holistic approach and leverages the high performance of Crail distributed data store to deliver gains. It uses Crail store to efficiently manage I/O resources, storage and networking devices, memory registrations, client sessions, data distribution, etc. Consequently, the shuffle operation becomes as simple as writing and reading files. And recall that Crail store is designed as a fast data bus for the intermediate data. The shuffle operation is just one of many operations that can be accelerated using Crail store. Beyond these operations, the modular architecture of Crail store enables us to seamlessly leverage different storage types (DRAM, NVMe, and more), perform tiering, support disaggregation, share inter-job data, jointly optimize I/O resources for various workloads, etc. These capabilities and performance gains give us confidence in the design choices we made for the Crail project.
&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;performance-comparison&quot;&gt;Performance comparison&lt;/h3&gt;
&lt;div style=&quot;text-align: justify&quot;&gt;
&lt;p&gt;Lets start by quantitatively assessing performance gains from the Crail shuffle plugin and SparkRDMA. As described above, SparkRDMA can be operated in two different modes. Users decide which mode to use by selecting a particular type of shuffle writer (spark.shuffle.rdma.shuffleWriterMethod). The Wrapper shuffle writer writes shuffle data to files between the stages, the Chunked shuffle writer stores shuffle data in memory. We evaluate both writer methods for terasort and SQL equijoin.
&lt;/p&gt;
&lt;/div&gt;
&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;{{ site.base }}/img/blog/rdma-shuffle/terasort.svg&quot; width=&quot;550&quot; /&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;text-align: justify&quot;&gt;
&lt;p&gt;
First we run &lt;a href=&quot;https://github.com/zrlio/crail-spark-terasort&quot;&gt;terasort&lt;/a&gt; on our 8+1 machine cluster (see above). We sort 200GB, thus, each node gets 25GB of data (equal distribution). We further did a basic search of the parameter space for each of the systems to find the best possible configuration. In all the experiments we use 8 executors with 12 cores each. Note that in a typical Spark run more CPU cores than assigned are engaged because of garbabge collection, etc. In our test runs assigning 12 cores lead to the best performance.
&lt;/p&gt;
&lt;p&gt;
The plot above shows runtimes of the various configuration we run with terasort. SparkRDMA with the Wrapper shuffle writer performance slightly better (3-4%) than vanilla Spark whereas the Chunked shuffle writer shows a 30% overhead. On a quick inspection we found that this overhead stems from memory allocation and registration for the shuffle data that is kept in memory between the stages. Compared to vanilla Spark, Crail's shuffle plugin shows performance improvement of around 235%.
&lt;/p&gt;
&lt;/div&gt;
&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;{{ site.base }}/img/blog/rdma-shuffle/sql.svg&quot; width=&quot;550&quot; /&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div style=&quot;text-align: justify&quot;&gt;
&lt;p&gt;
For our second workload we choose the &lt;a href=&quot;https://github.com/zrlio/sql-benchmarks&quot;&gt;SQL equijoin&lt;/a&gt; with a &lt;a href=&quot;https://github.com/zrlio/spark-nullio-fileformat&quot;&gt;special fileformat&lt;/a&gt; that allows data to be generated on the fly. By generating data on the fly we eliminate any costs for reading data from storage and focus entirely on the shuffle performance. The shuffle data size is around 148GB. Here the Wrapper shuffle writer is slightly slower than vanilla Spark but instead the Chunked shuffle writer is roughly the same amount faster. The Crail shuffle plugin again delivers a great performance increase over vanilla Spark.
&lt;/p&gt;
&lt;/div&gt;

&lt;div style=&quot;text-align: justify&quot;&gt;
&lt;p&gt;Please let us know if your have recommendations about how these experiments can be improved.&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;

&lt;div style=&quot;text-align: justify&quot;&gt;
&lt;p&gt;
These benchmarks validate our belief that a &quot;last-mile&quot; integration cannot deliver the same performance gains as a holistic approach, i.e. one has to look at the whole picture in how to integrate RDMA into Spark applications (and for that matter any framework or application). Only replacing the data transfer alone does not lead to the anticipated performance increase. We learned this the hard way when we intially started working on Crail.
&lt;/p&gt;

&lt;/div&gt;

</content>
<author>
<name>Jonas Pfefferle, Patrick Stuedi, Animesh Trivedi, Bernard Metzler, Adrian Schuepbach</name>
</author>
<category term="blog" />
<summary>This blog is comparing the shuffle performance of Crail with SparkRDMA, an alternative RDMA-based shuffle plugin for Spark.</summary>
</entry>
<entry>
<title>Crail Storage Performance – Part II: NVMf</title>
<link href="http://crail.incubator.apache.org//blog/2017/08/crail-nvme-fabrics-v1.html" rel="alternate" type="text/html" title="Crail Storage Performance -- Part II: NVMf" />
<published>2017-08-22T00:00:00+02:00</published>
<updated>2017-08-22T00:00:00+02:00</updated>
<id>http://crail.incubator.apache.org//blog/2017/08/crail-nvme-fabrics-v1</id>
<content type="html" xml:base="http://crail.incubator.apache.org//blog/2017/08/crail-nvme-fabrics-v1.html">&lt;div style=&quot;text-align: justify&quot;&gt;
&lt;p&gt;
This is part II of our series of posts discussing Crail's raw storage performance. This part is about Crail's NVMe storage tier, a low-latency flash storage backend for Crail completely based on user-level storage access.
&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;hardware-configuration&quot;&gt;Hardware Configuration&lt;/h3&gt;

&lt;p&gt;The specific cluster configuration used for the experiments in this blog:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cluster
    &lt;ul&gt;
      &lt;li&gt;8 node OpenPower cluster&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Node configuration
    &lt;ul&gt;
      &lt;li&gt;CPU: 2x OpenPOWER Power8 10-core @2.9Ghz&lt;/li&gt;
      &lt;li&gt;DRAM: 512GB DDR4&lt;/li&gt;
      &lt;li&gt;4x 512 GB Samsung 960Pro NVMe SSDs (512Byte sector size, no metadata)&lt;/li&gt;
      &lt;li&gt;Network: 1x100Gbit/s Mellanox ConnectX-4 IB&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Software
    &lt;ul&gt;
      &lt;li&gt;RedHat 7.3 with Linux kernel version 3.10&lt;/li&gt;
      &lt;li&gt;Crail 1.0, internal version 2843&lt;/li&gt;
      &lt;li&gt;SPDK git commit 5109f56ea5e85b99207556c4ff1d48aa638e7ceb with patches for POWER support&lt;/li&gt;
      &lt;li&gt;DPDK git commit bb7927fd2179d7482de58d87352ecc50c69da427&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;the-crail-nvmf-storage-tier&quot;&gt;The Crail NVMf Storage Tier&lt;/h3&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
Crail is a framework that allows arbitrary storage backends to be added by implementing the Crail storage interface. A storage backend manages the point-to-point data transfers on a per block granularity between a Crail client and a set of storage servers. The Crail storage interface essentially consists of three virtual functions, which simplified look like this:
&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//Server-side interface: donate storage resources to Crail
StorageResource allocateResource();
//Client-side interface: read/write remote/local storage resources
writeBlock(BlockInfo, ByteBuffer);
readBlock(BlockInfo, ByteBuffer);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
A specific implementation of this interface provides an efficient mapping of Crail storage operations to the actual storage and network hardware the backend is exporting. Crail comes with two native storage backends, an RDMA-based DRAM backend and an RDMA-based NVMe backend, but other storage backends are available as well (e.g., Netty) and we plan to provide more custom backends in the future as new storage and network technologies are emerging. 
&lt;/p&gt;
&lt;p&gt;
The Crail NVMf storage backend we evaluate in this blog provides user-level access to local and remote flash through the NVMe over Fabrics protocol. Crail NVMf is implemented using &lt;a href=&quot;https://github.com/zrlio/disni&quot;&gt;DiSNI&lt;/a&gt;, a user-level network and storage interface for Java offering both RDMA and NVMf APIs. DiSNI itself is based on &lt;a href=&quot;http://www.spdk.io&quot;&gt;SPDK&lt;/a&gt; for its NVMf APIs. 
&lt;/p&gt;
&lt;p&gt;
The server side of the NVMf backend is designed in a way that each server process manages exactly one NVMe drive. On hosts with multiple NVMe drives one may start several Crail NVMf servers. A server is setting up an NVMf target through DiSNI and implements the allocateResource() storage interface by allocating storage regions from the NVMe drive (basically splits up the NVMe namespace into smaller segments). The Crail storage runtime makes information about storage regions available to the Crail namenode, from where regions are further broken down into smaller units called blocks that make up files in Crail.
&lt;/p&gt;
&lt;p&gt;
The Crail client runtime invokes the NVMf client interface during file read/write operations for all data transfers on NVMf blocks. Using the block information provided by the namenode, the NVMf storage client implementation is able to connect to the appropriate NVMf target and perform the data operations using DiSNI's NVMf API.
&lt;/p&gt;
&lt;p&gt;
One downside of the NVMe interface is that byte level access is prohibited. Instead data operations have to be issued for entire drive sectors which are typically 512Byte or 4KB large (we used 512Byte sector size in all the experiments shown in this blog). As we wanted to use the standard NVMf protocol (and Crail has a client driven philosophy) we needed to implement byte level access at the client side. For reads this can be achieved in a straight forward way by reading the whole sector and copying out the requested part. For writes that modify a certain subrange of a sector that has already been written before we need to do a read modify write operation.
&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;performance-comparison-to-native-spdk-nvmf&quot;&gt;Performance comparison to native SPDK NVMf&lt;/h3&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
We perform latency and throughput measurement of our Crail NVMf storage tier against a native SPDK NVMf benchmark to determine how much overhead our implementation adds. The first plot shows random read latency on a single 512GB Samsung 960Pro accessed remotely through SPDK. For Crail we also show the time it takes to perform a metadata operations. You can run the Crail benchmark from the command line like this:
&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./bin/crail iobench -t readRandom -b false -s &amp;lt;size&amp;gt; -k &amp;lt;iterations&amp;gt; -w 32 -f /tmp.dat
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and SPDK:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./perf -q 1 -s &amp;lt;size&amp;gt; -w randread -r 'trtype:RDMA adrfam:IPv4 traddr:&amp;lt;ip&amp;gt; trsvcid:&amp;lt;port&amp;gt;' -t &amp;lt;time in seconds&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
The main take away from this plot is that the time it takes to perform a random read operation on a NVMe-backed file in Crail takes only about 7 microseconds more time than fetching the same amount of data over a point-to-point SPDK connection. This is impressive because it shows that using Crail a bunch of NVMe drives can be turned into a fully distributed storage space at almost no extra cost. The 7 microseconds are due to Crail having to look up the specific NVMe storage node that holdes the data -- an operation which requires one extra network roundtrip (client to namenode). The experiment represents an extreme case where no metadata is cached at the client. In practice, file blocks are often accessed multiple times in which case the read latency is further reduced. Also note that unlike SPDK which is a native library, Crail delivers data directly into Java off-heap memory. 
&lt;/p&gt;
&lt;/div&gt;

&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;{{ site.base }}/img/blog/crail-nvmf/latency.svg&quot; width=&quot;550&quot; /&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
The second plot shows sequential read and write throughput with a transfer size of 64KB and 128 outstanding operations. The Crail throughput benchmark can be run like this:
&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./bin/crail iobench -t readAsync -s 65536 -k &amp;lt;iterations&amp;gt; -b 128 -w 32 -f /tmp.dat
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and SPDK:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./perf -q 128 -s 65536 -w read -r 'trtype:RDMA adrfam:IPv4 traddr:&amp;lt;ip&amp;gt; trsvcid:&amp;lt;port&amp;gt;' -t &amp;lt;time in seconds&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
For sequential operations in Crail, metadata fetching is inlined with data operations as described in the &lt;a href=&quot;{{ site.base }}/blog/2017/08/crail-memory.html&quot;&gt;DRAM&lt;/a&gt; blog. This is possible as long as the data transfer has a lower latency than the metadata RPC, which is typically the case. As a consequence, our NVMf storage tier reaches the same throughput as the native SPDK benchmark (device limit).
&lt;/p&gt;
&lt;/div&gt;
&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;{{ site.base }}/img/blog/crail-nvmf/throughput.svg&quot; width=&quot;550&quot; /&gt;&lt;/div&gt;

&lt;h3 id=&quot;sequential-throughput&quot;&gt;Sequential Throughput&lt;/h3&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
Let us look at the sequential read and write throughput for buffered and direct streams and compare them to a buffered Crail stream on DRAM. All benchmarks are single thread/client performed against 8 storage nodes with 4 drives each, cf. configuration above. In this benchmark we use 32 outstanding operations for the NVMf storage tier buffered stream experiments by using a buffer size of 16MB and a slice size of 512KB, cf. &lt;a href=&quot;{{ site.base }}/blog/2017/07/crail-memory.html&quot;&gt;part I&lt;/a&gt;. The buffered stream reaches line speed at a transfer size of around 1KB and shows only slightly slower performance when compared to the DRAM tier buffered stream. However we are only using 2 outstanding operations with the DRAM tier to achieve these results. Basically for sizes smaller than 1KB the buffered stream is limited by the copy speed to fill the application buffer. The direct stream reaches line speed at around 128KB with 128 outstanding operations. Here no copy operation is performed for transfer size greater than 512Byte (sector size). The command to run the Crail buffered stream benchmark:
&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./bin/crail iobench -t read -s &amp;lt;size&amp;gt; -k &amp;lt;iterations&amp;gt; -w 32 -f /tmp.dat
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The direct stream benchmark:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./bin/crail iobench -t readAsync -s &amp;lt;size&amp;gt; -k &amp;lt;iterations&amp;gt; -b 128 -w 32 -f /tmp.dat
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;{{ site.base }}/img/blog/crail-nvmf/throughput2.svg&quot; width=&quot;550&quot; /&gt;&lt;/div&gt;

&lt;h3 id=&quot;random-read-latency&quot;&gt;Random Read Latency&lt;/h3&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
Random read latency is limited by the flash technology and we currently see around 70us when performing sector size accesses to the device with the Crail NVMf backend. In comparison, remote DRAM latencies with Crail are about 7-8x faster. However, we believe that this will change in the near future with new technologies like PCM. Intel's Optane drives already can deliver random read latencies of around 10us. Considering that there is an overhead of around 10us to access a drive with Crail from anywhere in the cluster, using such a device would put random read latencies somewhere around 20us which is only half the performance of our DRAM tier.
&lt;/p&gt;
&lt;/div&gt;

&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;{{ site.base }}/img/blog/crail-nvmf/latency2.svg&quot; width=&quot;550&quot; /&gt;&lt;/div&gt;

&lt;h3 id=&quot;tiering-dram---nvmf&quot;&gt;Tiering DRAM - NVMf&lt;/h3&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
In this paragraph we show how Crail can leverage flash memory when there is not sufficient DRAM available in the cluster to hold all the data. As described in the &lt;a href=&quot;{{ site.base }}/overview/&quot;&gt;overview&lt;/a&gt; section, if you have multiple storage tiers deployed in Crail, e.g. the DRAM tier and the NVMf tier, Crail by default first uses up all available resources of the faster tier. Basically a remote resource of a faster tier (e.g. remote DRAM) is preferred over a slower local resource (e.g., local flash), motivated by the fast network. This is what we call horizontal tiering.
&lt;/p&gt;
&lt;/div&gt;
&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;{{ site.base }}/img/blog/crail-nvmf/crail_tiering.png&quot; width=&quot;500&quot; vspace=&quot;10&quot; /&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
In the following 200G Terasort experiment we gradually limit the DRAM resources in Crail while adding more flash to the Crail NVMf storage tier. Note that here Crail is used for both input/output as well as shuffle data. The figure shows that by putting all the data in flash we only increase the sorting time by around 48% compared to the configuration where all the data resides in DRAM. Considering the cost of DRAM and the advances in technology described above we believe cheaper NVM storage can replace DRAM for most of the applications with only a minor performance decrease. Also, note that even with 100% of the data in NVMe, Spark/Crail is still faster than vanilla Spark with all the data in memory. The vanilla Spark experiment uses Alluxio for input/output and RamFS for the shuffle data.
&lt;/p&gt;
&lt;/div&gt;

&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;{{ site.base }}/img/blog/crail-nvmf/tiering.svg&quot; width=&quot;550&quot; /&gt;&lt;/div&gt;

&lt;p&gt;To summarize, in this blog we have shown that the NVMf storage backend for Crail – due to its efficient user-level implementation – offers latencies and throughput very close to the hardware speed. The Crail NVMf storage tier can be used conveniently in combination with the Crail DRAM tier to either save cost or to handle situations where the available DRAM is not sufficient to store the working set of a data processing workload.&lt;/p&gt;

</content>
<author>
<name>Jonas Pfefferle</name>
</author>
<category term="blog" />
<summary>This is part II of our series of posts discussing Crail's raw storage performance. This part is about Crail's NVMe storage tier, a low-latency flash storage backend for Crail completely based on user-level storage access.</summary>
</entry>
<entry>
<title>Crail Storage Performance – Part I: DRAM</title>
<link href="http://crail.incubator.apache.org//blog/2017/08/crail-memory.html" rel="alternate" type="text/html" title="Crail Storage Performance -- Part I: DRAM" />
<published>2017-08-18T00:00:00+02:00</published>
<updated>2017-08-18T00:00:00+02:00</updated>
<id>http://crail.incubator.apache.org//blog/2017/08/crail-memory</id>
<content type="html" xml:base="http://crail.incubator.apache.org//blog/2017/08/crail-memory.html">&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
It's summer and there is some time to blog about things. This blog post is the first in a series of three posts where we illustrate Crail's raw storage performance on our 100Gbps cluster. In part I we cover Crail's DRAM storage tier, part II will be about Crail's NVMe flash storage tier, and part III will be about Crail's metadata performance. 
&lt;/p&gt;
&lt;p&gt;
I recently read the &lt;a href=&quot;https://www.usenix.org/conference/atc17/technical-sessions/presentation/lu&quot;&gt;Octopus file system&lt;/a&gt; Usenix'17 paper, where the authors show Crail performance numbers that do not match the performance we measure on our clusters. Like many other distributed systems, Crail also requires a careful system configuration and wrong or mismatching configuration settings can easily lead to poor performance. Therefore, in this blog we try to point out the key parameter settings that are necessary to obtain proper performance numbers with Crail. 
&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;hardware-configuration&quot;&gt;Hardware Configuration&lt;/h3&gt;

&lt;p&gt;The specific cluster configuration used for the experiments in this blog:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cluster
    &lt;ul&gt;
      &lt;li&gt;8 node OpenPower cluster (for Crail)&lt;/li&gt;
      &lt;li&gt;2 node X86 cluster (for RAMCloud)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;OpenPower Node configuration
    &lt;ul&gt;
      &lt;li&gt;CPU: 2x OpenPOWER Power8 10-core @2.9Ghz&lt;/li&gt;
      &lt;li&gt;DRAM: 512GB DDR4&lt;/li&gt;
      &lt;li&gt;Network: 1x100Gbit/s Ethernet Mellanox ConnectX-4 EN (Ethernet/RoCE)
        &lt;ul&gt;
          &lt;li&gt;RDMA send/recv latency, ib_send_lat (RTT): 3.1us&lt;/li&gt;
          &lt;li&gt;RDMA read latency, ib_read_lat (RTT): 2.3us&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Software
    &lt;ul&gt;
      &lt;li&gt;RedHat 7.2 with Linux kernel version 4.10.13&lt;/li&gt;
      &lt;li&gt;Crail 1.0, internal version 2842&lt;/li&gt;
      &lt;li&gt;Alluxio 1.4&lt;/li&gt;
      &lt;li&gt;RAMCloud commit f53202398b4720f20b0cdc42732edf48b928b8d7&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;anatomy-of-a-crail-data-operation&quot;&gt;Anatomy of a Crail Data Operation&lt;/h3&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
Data operations in Crail -- such as the reading or writing of files -- are internally composed of metadata operations and actual data transfers. Let's look at a simple Crail application that opens a file and reads the file sequentially:
&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CrailConfiguration conf = new CrailConfiguration();
CrailFS fs = CrailFS.newInstance(conf);
CrailFile file = fs.lookup(filename).get().asFile();
CrailInputStream stream = file.getDirectInputStream();
while(stream.available() &amp;gt; 0){
    Future&amp;lt;Buffer&amp;gt; future = stream.read(buf);
    //Do something useful
    ...
    //Await completion of operation
    future.get();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
One challenge with file read/write operations is to avoid blocking in case block metadata information is missing. Crail caches block metadata at the client, but caching is ineffective for both random reads and write-once read-once data. To avoid blocking for sequential read/write operations, Crail interleaves metadata operations and actual data transfers. Each read operation always triggers the lookup of block metadata for the next block immediately after issuing the RDMA read operation for the current block. The asynchronous and non-blocking nature of RDMA allows both operations to be executed in the process context of the application, without context switching or any additional background threads. The figure illustrates the case of one outstanding operation a time. The asynchronous Crail storage API, however, permits any number of outstanding operations. 
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;{{ site.base }}/img/blog/crail-memory/anatomy.png&quot; width=&quot;420&quot; /&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
As a side note, it's also worth mentioning that Crail does not actually use RPCs for the data transfers but uses RDMA one-sided read/write operations instead. Moreover, Crail is designed from ground up for byte-addressable storage and memory. For instance, files in Crail are essentially a sequence of virtual memory windows on different hosts which allows for a very effective handling of small data operations. As shown in the figure, during the last operation, with only a few bytes left to be read, the byte-granular nature of Crail's block access protocol makes sure that only the relevant bytes are transmitted over the network, as opposed to transmitting the entire block. 
&lt;/p&gt;
&lt;p&gt;
The basic read/write logic shown in the figure above is common to all storage tiers in Crail, including the NVMe flash tier. In the remainder of this post, we specificially look at the performance of Crail's DRAM storage tier though. 
&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;sequential-readwrite-throughput&quot;&gt;Sequential Read/Write Throughput&lt;/h3&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
Let's start by looking at sequential read/write performance. These benchmarks can be run easily from the command line. Below  is an example for a sequential write experiment issuing 100M write operations of size 1K to produce a file of roughly 100GB size. The -w switch indicates that we are using 32 warmup operations. 
&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./bin/crail iobench -t write -s 1024 -k 100000000 -w 32 -f /tmp.dat
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
Crail offers direct I/O streams as well as buffered streams. For sequential operations it is important to use the buffered streams. Even though the buffered streams impose one extra copy (from the Crail stream to the application buffer) they are typically more effective for sequential access as they make sure that at least one network operation is in-flight at any time. The buffer size in a Crail buffered stream and the number of oustanding operations can be controlled by setting the buffersize and the slicesize properties in crail-site.conf. For our experiments we used a 1MB buffer per stream sliced up into two slices of 512K each which eventually leads to two operations in flight. 
&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;crail.buffersize     1048576
crail.slicesize      524288
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
The figure below illustrates the sequential write (top) and read (bottom) performance of Crail (DRAM tier) for different application buffer sizes (not to be mixed up with crail.buffersize used within streams) and shows a comparison to other systems. As of now, we only show a comparison with Alluxio, an in-memory file system for caching data in Spark or Hadoop applications. We are, however, working on including results for other storage systems such as Apache Ignite and GlusterFS and we plan to update the blog post accordingly soon. If there is a particular storage system that is not included but you would like to see included as a comparison, please write us. And &lt;b&gt;important&lt;/b&gt;: if you find that the results we show for a particular storage system do not match your experience, please write to us too, we are happy to revisit the configuration.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;{{ site.base }}/img/blog/crail-memory/write.svg&quot; width=&quot;550&quot; /&gt;&lt;/div&gt;
&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;{{ site.base }}/img/blog/crail-memory/read.svg&quot; width=&quot;550&quot; /&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
One first observation from the figure is that there is almost no difference in performance for write and read operations. Second, at a buffer size of around 1K Crail reaches a bandwidth close to 95Gbit/s (for read), which is approaching the network hardware limit of 100Gbps. And third, Crail performs significantly faster than other in-memory storage systems, in this case Alluxio. This because Crail is built on of user-level networking and thereby avoids the overheads of both the Linux network stack (memory copies, context switches, etc.) and the Java runtime. 
&lt;/p&gt;
&lt;p&gt;
Note that both figures show single-client performance numbers. With Crail being a user-level storage system executing I/O operations directly within the application context this means the entire benchmark is truly runninig on one single core. Often, systems that perform poorly in single-client experiments are being defended saying that nobody cares about the single-client performance. Especially throughput problems can easily be fixed by adding more cores. This is, however, not at all cloudy to say the least. At the level hardware is multiplexed and priced in today's cloud computing data centers every core counts. The figure below shows a simple Spark group-by experiment on the same 8-node cluster. As can be seen, with Crail the benchmark executes faster using a single core per machine than with default Spark using 8 cores per machine, which is a direct consequence from Crail's superb single-core I/O performance. 
&lt;/p&gt;
&lt;/div&gt;

&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;{{ site.base }}/img/blog/crail-memory/crail-groupby.svg&quot; width=&quot;550&quot; /&gt;&lt;/div&gt;
&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;{{ site.base }}/img/blog/crail-memory/spark-groupby.svg&quot; width=&quot;550&quot; /&gt;&lt;/div&gt;

&lt;h3 id=&quot;random-read-latency&quot;&gt;Random Read Latency&lt;/h3&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
Typically, distributed storage systems are either built for sequential access to large data sets (e.g., HDFS) or they are optimized for random access to small data sets (e.g., key/value stores). We have already shown that Crail performs well for large sequentially accessed data sets, let's now look at the latencies of small random read operations. For this, we mimic the behavior of a key/value store by storing key/value pairs in Crail files with the key being the filename. We then measure the time it takes to open the file and read its content. Again, the benchmark can easily be executed from the command line. The following example issues 1M get() operations on a small file filled with a 4 byte value. 
&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./bin/crail iobench -t getkey -s 4 -k 1000000 -f /tmp.dat -w 32
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
The figure below illustrates the latencies of get() operations for different key/value sizes and compares them to the latencies we obtained with RAMCloud for the same type of operations (measured using RAMClouds C and Java APIs). RAMCloud is a low-latency key/value store implemented using RDMA. RAMCloud actually provides durable storage by asynchronously replicating data onto backup devices. However, at any point in time all the data is held in DRAM and read requests will be served from DRAM directly. Up to our knowledge, RAMCloud is the fastest key/value store that is (a) available open source and (b) can be deployed in practice as a storage platform for applications. Other similar RDMA-based storage systems we looked at, like FaRM or HERD, are either not open source or they do not provide a clean separation between storage system, API and clients. 
&lt;/p&gt;
&lt;/div&gt;
&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;{{ site.base }}/img/blog/crail-memory/latency.svg&quot; width=&quot;550&quot; /&gt;&lt;/div&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
As can be seen from the figure, Crail's latencies for reading small files range from 10us to 20us for files smaller than 256K. The first observation is that these latency numbers are very close to the RAMCloud get() latencies obtained using the RAMCloud C API. Mainly, the latency difference between the two systems comes from the extra network roundtrip that is required in Crail to open the file, an operation which involves the Crail namenode. Once the file size reaches 64K, the cost for the extra roundtrip is amortized and the Crail latencies start to match the RAMCloud latencies. The second observation from the figure is that Crail offers lower latencies than the RAMCloud Java API for key/value sizes of 16K and bigger. This is because Crail, which is implemented in Java itself, integrates natively with the Java memory system. For instance, Crail's raw stream APIs permits clients to pass Java off-heap ByteBuffers which can be accessed by the network interface directly, avoiding data copies along the way. That being said we also understand that the Java API is not RAMCloud's primary API and could probably be optimized further.
&lt;/p&gt;
&lt;p&gt;
All in all the main take away here is that -- despite Crail offering a fully hierchical storage namespace and high-performance operations on large data sets -- the latencies for looking up and reading small data sets are in the same ballpark as the get() latencies of some of the fastest key/value stores out there.
&lt;/p&gt;
&lt;p&gt;
The latency advantages of Crail are beneficial also at the application level. The figure below illustrates this in a Spark broadcast experiment. Broadcast objects in Spark are typically small read-only variables that are shared across the cluster. The Crail broadcast module for Spark uses Crail as a storage backend to make broadcast variables accessible by the different tasks. As can be seen, using Crail broadcast objects can be accessed in just a few microseconds, while the same operation in default Spark takes milliseconds.
&lt;/p&gt;
&lt;/div&gt;

&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;{{ site.base }}/img/blog/crail-memory/cdf-broadcast-128-read.svg&quot; width=&quot;550&quot; /&gt;&lt;/div&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
To summarize, in this blog post we have shown that Crail's DRAM storage tier provides both throughput and latency close to the hardware limits. These performance benefits enable high-level data processing operations like shuffle or broadcast to be implemented faster and/or more efficient.
&lt;/p&gt;

&lt;/div&gt;
</content>
<author>
<name>Patrick Stuedi</name>
</author>
<category term="blog" />
<summary> It's summer and there is some time to blog about things. This blog post is the first in a series of three posts where we illustrate Crail's raw storage performance on our 100Gbps cluster. In part I we cover Crail's DRAM storage tier, part II will be about Crail's NVMe flash storage tier, and part III will be about Crail's metadata performance. I recently read the Octopus file system Usenix'17 paper, where the authors show Crail performance numbers that do not match the performance we measure on our clusters. Like many other distributed systems, Crail also requires a careful system configuration and wrong or mismatching configuration settings can easily lead to poor performance. Therefore, in this blog we try to point out the key parameter settings that are necessary to obtain proper performance numbers with Crail. </summary>
</entry>
<entry>
<title>Openpower</title>
<link href="http://crail.incubator.apache.org//blog/2017/08/openpower.html" rel="alternate" type="text/html" title="Openpower" />
<published>2017-08-04T00:00:00+02:00</published>
<updated>2017-08-04T00:00:00+02:00</updated>
<id>http://crail.incubator.apache.org//blog/2017/08/openpower</id>
<content type="html" xml:base="http://crail.incubator.apache.org//blog/2017/08/openpower.html">&lt;p&gt;Crail on OpenPower discussed by Peter Hofstee on &lt;a href=&quot;https://www.youtube.com/watch?v=f-pgMaEmqn4&amp;amp;feature=youtu.be&amp;amp;platform=hootsuite&quot;&gt;Youtube&lt;/a&gt;&lt;/p&gt;
</content>
<category term="news" />
<summary>Crail on OpenPower discussed by Peter Hofstee on Youtube</summary>
</entry>
<entry>
<title>Disni</title>
<link href="http://crail.incubator.apache.org//blog/2017/06/disni.html" rel="alternate" type="text/html" title="Disni" />
<published>2017-06-17T00:00:00+02:00</published>
<updated>2017-06-17T00:00:00+02:00</updated>
<id>http://crail.incubator.apache.org//blog/2017/06/disni</id>
<content type="html" xml:base="http://crail.incubator.apache.org//blog/2017/06/disni.html">&lt;p&gt;DiSNI, the RDMA and NVMe user-level stack used in Crail is now available on &lt;a href=&quot;https://search.maven.org/&quot;&gt;Maven Central&lt;/a&gt;&lt;/p&gt;
</content>
<category term="news" />
<summary>DiSNI, the RDMA and NVMe user-level stack used in Crail is now available on Maven Central</summary>
</entry>
</feed>
